## 1. 题目

### E07218: 献给阿尔吉侬的花束

bfs, http://cs101.openjudge.cn/practice/07218/

思路：
这题dfs会超时，在bfs过程中要求记忆好走过的路防止回头路


代码：

```python
from collections import deque

def find_shortest_path(maze, R, C):
    # 查找起点位置
    start = None
    for i in range(R):
        for j in range(C):
            if maze[i][j] == 'S':
                start = (i, j)
                break
        if start:
            break
    
    if not start:
        return 'oop!'
    
    directions = [(-1, 0), (1, 0), (0, 1), (0, -1)]
    visited = [[False] * C for _ in range(R)]
    queue = deque([(start[0], start[1], 0)])  # (x, y, 步数)
    visited[start[0]][start[1]] = True
    
    while queue:
        x, y, steps = queue.popleft()
        
        for dx, dy in directions:
            nx, ny = x + dx, y + dy
            
            if 0 <= nx < R and 0 <= ny < C and not visited[nx][ny]:
                if maze[nx][ny] == 'E':
                    return steps + 1
                elif maze[nx][ny] == '.':
                    visited[nx][ny] = True
                    queue.append((nx, ny, steps + 1))
    
    return 'oop!'

n = int(input())
for _ in range(n):
    R, C = map(int, input().split())
    maze = []
    for i in range(R):
        maze.append(list(input().strip()))
    
    result = find_shortest_path(maze, R, C)
    print(result)
```



代码运行截图 <mark>（至少包含有"Accepted"）</mark>

![alt text](image.png)



### M27925: 小组队列

dict, queue, http://cs101.openjudge.cn/practice/27925/


思路：
在队列里只进队组号，然后用一个字典记录每组的队列，注意散户的处理


代码：

```python
from collections import deque

n = int(input())
groups = [set(input().split()) for _ in range(n)]

queue = deque()
group_queues = [deque() for _ in range(n + 1)]  # 额外一个给散户

INDIVIDUAL_GROUP = n  # 散户的组号

while True:
    signal = input().strip()
    if signal == 'STOP':
        break
        
    if signal.startswith('E'):
        num = signal.split()[1]
        group_found = False
        
        # 查找分组
        for i in range(n):
            if num in groups[i]:
                if not group_queues[i]:
                    queue.append(i)
                group_queues[i].append(num)
                group_found = True
                break
        
        # 散户
        if not group_found:
            if not group_queues[INDIVIDUAL_GROUP]:
                queue.append(INDIVIDUAL_GROUP)
            group_queues[INDIVIDUAL_GROUP].append(num)
                
    elif signal.startswith('D'):
        if queue:
            first_group = queue[0]
            if group_queues[first_group]:
                result = group_queues[first_group].popleft()
                print(result)
                if not group_queues[first_group]:
                    queue.popleft()
```



代码运行截图 <mark>（至少包含有"Accepted"）</mark>

![alt text](image-1.png)



### M04089: 电话号码

trie, http://cs101.openjudge.cn/practice/04089/

思路：
字典树的直接应用，展示其数据结构在处理前缀上的优越性


代码：

```python
class TrieNode:
    def __init__(self):
        self.children = {}
        self.is_end = False

class Trie:
    def __init__(self):
        self.root = TrieNode()
    
    def insert_and_check(self, phone):
        node = self.root
        for ch in phone:
            if ch not in node.children:
                node.children[ch] = TrieNode()
            node = node.children[ch]
            # 如果路径上遇到一个完整号码的结尾，说明当前号码包含前缀
            if node.is_end:
                return False
        # 插入完成后，如果该节点还有子节点，说明当前号码是别的号码的前缀
        if node.children:
            return False
        node.is_end = True
        return True

def main():
    t = int(input().strip())
    for _ in range(t):
        n = int(input().strip())
        phones = [input().strip() for _ in range(n)]
        # 按长度排序，确保先插入短号码
        phones.sort(key=lambda x: len(x))
        
        trie = Trie()
        consistent = True
        for phone in phones:
            if not trie.insert_and_check(phone):
                consistent = False
                break
        print("YES" if consistent else "NO")

if __name__ == "__main__":
    main()
```



代码运行截图 <mark>（至少包含有"Accepted"）</mark>
![alt text](image-2.png)




### M3532.针对图的路径存在性查询I

disjoint set, https://leetcode.cn/problems/path-existence-queries-in-a-graph-i/

思路：
使用并查集处理，如果两个点相连则加入一个并查集，这样把图变成一个个连通分支，进行划分查找答案时直接查询即可


代码

```python
class Solution:
    def pathExistenceQueries(self, n: int, nums: List[int], maxDiff: int, queries: List[List[int]]) -> List[bool]:
        fa=list(range(n))

        def find(i):
            if fa[i]==i:return i
            fa[i]=find(fa[i])
            return fa[i]
        
        def merge(i,j):
            x,y=find(i),find(j)
            fa[y]=x
        
        for i,j in pairwise(range(n)):
            if nums[j]-nums[i]<=maxDiff:
                merge(i,j)
                
        ans=[False]*len(queries)
        cnt=0
        for u,v in queries:
            if find(u)==find(v):
                ans[cnt]=True
            cnt+=1
        return ans


```



代码运行截图<mark>（至少包含有"Accepted"）</mark>

![alt text](image-3.png)



### M19943: 图的拉普拉斯矩阵

OOP, graph, implementation, http://cs101.openjudge.cn/pctbook/E19943/

要求创建Graph, Vertex两个类，建图实现。

思路：
题目不难主要是熟悉如何建图


代码

```python
class Vertex:
    def __init__(self, id):
        self.id = id
        self.neighbors = set()
        self.degree = 0
    
    def add_neighbor(self, neighbor_id):
        """添加邻居顶点"""
        if neighbor_id not in self.neighbors:
            self.neighbors.add(neighbor_id)
            self.degree = len(self.neighbors)
    
    def __str__(self):
        return f"Vertex {self.id}: degree={self.degree}, neighbors={sorted(self.neighbors)}"

class Graph:
    def __init__(self, n):
        self.n = n  # 顶点数
        self.vertices = [Vertex(i) for i in range(n)]
    
    def add_edge(self, a, b):
        """添加无向边"""
        if 0 <= a < self.n and 0 <= b < self.n:
            self.vertices[a].add_neighbor(b)
            self.vertices[b].add_neighbor(a)
    
    def get_degree_matrix(self):
        """获取度数矩阵 D"""
        degree_matrix = [[0] * self.n for _ in range(self.n)]
        for i in range(self.n):
            degree_matrix[i][i] = self.vertices[i].degree
        return degree_matrix
    
    def get_adjacency_matrix(self):
        """获取邻接矩阵 A"""
        adjacency_matrix = [[0] * self.n for _ in range(self.n)]
        for i in range(self.n):
            for neighbor in self.vertices[i].neighbors:
                adjacency_matrix[i][neighbor] = 1
        return adjacency_matrix
    
    def get_laplacian_matrix(self):
        """获取拉普拉斯矩阵 L = D - A"""
        degree_matrix = self.get_degree_matrix()
        adjacency_matrix = self.get_adjacency_matrix()
        
        laplacian_matrix = [[0] * self.n for _ in range(self.n)]
        for i in range(self.n):
            for j in range(self.n):
                laplacian_matrix[i][j] = degree_matrix[i][j] - adjacency_matrix[i][j]
        
        return laplacian_matrix
    
    def print_laplacian_matrix(self):
        """打印拉普拉斯矩阵"""
        laplacian_matrix = self.get_laplacian_matrix()
        for row in laplacian_matrix:
            print(' '.join(map(str, row)))
    
    def __str__(self):
        result = []
        for vertex in self.vertices:
            result.append(str(vertex))
        return '\n'.join(result)

def main():
    # 读取输入
    n, m = map(int, input().split())
    
    # 创建图
    graph = Graph(n)
    
    # 添加边
    for _ in range(m):
        a, b = map(int, input().split())
        graph.add_edge(a, b)
    
    # 输出拉普拉斯矩阵
    graph.print_laplacian_matrix()

if __name__ == "__main__":
    main()
```



代码运行截图<mark>（至少包含有"Accepted"）</mark>

![alt text](image-4.png)



### T25353: 排队

http://cs101.openjudge.cn/pctbook/T25353/

思路：
自己没有想好怎么做，查找了一些答案之后发现对于一个最大身高差不超过D的序列，可以认为他们联通，可以任意交换
这题 特别容易想当然，要仔细揣摩样例，并且考虑好特殊情况


代码：

```python
n, max_diff = map(int, input().split())
heights = []
for i in range(n):
    heights.append(int(input()))

teams = []
visited = [False] * n
count = 0

while count < n:
    teams.append([])
    current_max = 0
    current_min = 0
    
    for i in range(n):
        if visited[i]:
            continue
            
        if not teams[-1]:  
            teams[-1].append(heights[i])
            current_max = heights[i]
            current_min = heights[i]
            count += 1
            visited[i] = True
            continue
            
        if heights[i] < current_max - max_diff:
            if heights[i] < current_min:
                current_min = heights[i]
            continue
        elif heights[i] > current_min + max_diff:
            if heights[i] > current_max:
                current_max = heights[i]
            continue
        else:
            teams[-1].append(heights[i])
            visited[i] = True
            count += 1
            if heights[i] > current_max:
                current_max = heights[i]

result = []
for team in teams:
    team.sort()
    result.extend(team)

print('\n'.join(map(str, result)))
```



代码运行截图 <mark>（至少包含有"Accepted"）</mark>
![alt text](image-5.png)


## 2. 学习总结和个人收获

<mark>如果发现作业题目相对简单，有否寻找额外的练习题目，如“数算2025fall每日选做”、LeetCode、Codeforces、洛谷等网站上的题目。</mark>
这章对除了树以外的其他数据结构做了拓展，各有各的用法，要熟悉数据结构如何构造并理解为何使用。
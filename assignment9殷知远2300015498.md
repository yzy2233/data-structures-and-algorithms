## 1. 题目

### M02255: 重建二叉树

http://cs101.openjudge.cn/practice/02255/

思路：
根据根节点的位置在前序和中序中确定左子树，根和右子树，并且递归可以得到


代码

```python
def rebuild(p,i):
    if p=='':
        return ''
    if len(p)==1:
        return p
    root=p[0]
    t=i.find(root)
    return rebuild(p[1:t+1],i[:t])+rebuild(p[t+1:],i[t+1:])+root
try:
    while True:
        data = input().split()
        if not data:
            continue
        preord, inord = data[0], data[1]
        print(rebuild(preord,inord))
except EOFError:
    pass
```



代码运行截图 <mark>（至少包含有"Accepted"）</mark>
![alt text](image.png)




### M02774: 木材加工

http://cs101.openjudge.cn/practice/02774/

思路：
将最大长度作为求解量，用二分法节约时间。


代码

```python
n, m = map(int, input().split())
woods = []
for i in range(n):
    wood = int(input())
    woods.append(wood)


if m == 0:
    print(0)
    exit()

if n == 0:
    print(0)
    exit()

max_possible = sum(woods)
if m > max_possible:
    print(0)
    exit()

left, right = 1, max(woods)
result = 0

while left <= right:
    mid = (left + right) // 2
    total_pieces = 0
    
    for wood in woods:
        total_pieces += wood // mid
    
    if total_pieces >= m:
        result = mid
        left = mid + 1  
    else:
        right = mid - 1  

print(result)
```



代码运行截图 <mark>（至少包含有"Accepted"）</mark>
![alt text](image-1.png)




### M02788: 二叉树（2）

http://cs101.openjudge.cn/practice/02788/

思路：
观察到结点的左子树是他的两倍，右子树是他的两倍加一，找到n所在的层数并确定在这个不完整的层里有多少是我们需要的，其他层就直接按照完整一层计数即可。


代码

```python
while 1:
    m,n=map(int,input().split())
    if n==0 and m==0:
        break
    i=1
    right=m
    while 1:
        if m*(2**i)>n:
            break
        i+=1
        right=2*right+1
    s=0
    for j in range(0,i-1):
        s+=2**j
    s+=min(n,right)+1-m*(2**(i-1))
    print(s)

```



代码运行截图 <mark>（至少包含有"Accepted"）</mark>
![alt text](image-2.png)




### M04081: 树的转换 

http://cs101.openjudge.cn/practice/04081/


思路：

也是通过观察发现，二叉树的最大深度等于左边最长链长度加上该最长链的根属于兄弟中的排行

代码

```python
def solve():
    s = input().strip()
    stack = [(0, 0, 0)]  # (orig_depth, bin_depth, child_count)
    h1 = 0
    h2 = 0
    for ch in s:
        if ch == 'd':
            parent_orig, parent_bin, parent_child_count = stack[-1]
            new_orig = parent_orig + 1
            new_bin = parent_bin + parent_child_count + 1
            stack[-1] = (parent_orig, parent_bin, parent_child_count + 1)
            stack.append((new_orig, new_bin, 0))
            h1 = max(h1, new_orig)
            h2 = max(h2, new_bin)
        else:  # 'u'
            stack.pop()
    print(f"{h1} => {h2}")

if __name__ == "__main__":
    solve()
```



代码运行截图 <mark>（至少包含有"Accepted"）</mark>
![alt text](image-3.png)




### M04117: 简单的整数划分问题

dfs, dp, http://cs101.openjudge.cn/practice/04117/

思路：

经典dp问题，我使用了最直观的二维dp，这里时间要求很松我都没有加记忆化就过了，加上记忆化可以优化很多。

代码

```python
def dp(a, t):
    if t == 1:
        return 1
    if a == 0:
        return 1
    s = 0
    for i in range(0, a // t + 1):
        s += dp(a - i * t, t - 1)
    return s

def main():
    import sys
    for line in sys.stdin:
        n = int(line.strip())
        if 0 < n <= 50:
            print(dp(n, n))

if __name__ == "__main__":
    main()
```



代码运行截图 <mark>（至少包含有"Accepted"）</mark>
![alt text](image-4.png)




### M04137:最小新整数

monotonous-stack, http://cs101.openjudge.cn/practice/04137/

思路：

这题一开始很自然的想简单了，认为只需要删除最大的数即可。后续发现需要结合该数所在的位数考虑是否删除，总结下来是若是该数的后一个数小于该数，则可以删除，这一过程从高到低进行。

代码

```python
t = int(input())
for _ in range(t):
    n, k = map(int, input().split())
    digits = list(str(n))
    stack = []
    
    for digit in digits:
        while k > 0 and stack and stack[-1] > digit:
            stack.pop()
            k -= 1
        stack.append(digit)
    
    if k > 0:
        stack = stack[:-k]
    
    result = ''.join(stack).lstrip('0')
    print(result if result != '' else '0')
```



代码运行截图 <mark>（至少包含有"Accepted"）</mark>
![alt text](image-5.png)




## 2. 学习总结和收获

如果作业题目简单，有否额外练习题目，比如：OJ“计概2025fall每日选做”、CF、LeetCode、洛谷等网站题目。
这次的月考在难度上相比上次有所下降(?,觉得主要原因在于自己对于代码的实现并不够熟练，上一次的考题过程更为繁琐更花时间，而这次更多的时间用于思考而不是实现代码，所以做起来会轻松一点。最近关于树的练习还是很有成效，对于各种基本操作都比较熟悉。但也通过这次考题注意到数据结构的题发掘客观规律可以大大节约代码实现的成本和时间成本。
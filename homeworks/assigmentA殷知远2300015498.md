## 1. 题目

### T51.N皇后

backtracking, https://leetcode.cn/problems/n-queens/

思路：
与传统的八皇后问题类似，注意回溯，注意好判定条件，记得复制副本


代码：

```python
class Solution:
    def solveNQueens(self, n: int) -> List[List[str]]:
        def Queens(s,t):
            if t==n:
                ans.append(s[:])
                return 
            for i in range(n):
                signal=1
                for j in range(t):
                    if i==s[j]:
                        signal=0
                        break
                    if t-j==i-s[j]:
                        signal=0
                        break
                    if t-j==-i+s[j]:
                        signal=0
                        break
                if signal==0:
                    continue
                s[t]=i
                Queens(s,t+1)
                s[t]=-1
        ans=[]
        Queens([-1]*n,0)
        output=[]
        for k in range(len(ans)):
            o=[]
            for i in range(n):
                r=''
                for j in range(n):
                    if j==ans[k][i]:
                        r+='Q'
                    else:
                        r+='.'
                o.append(r)
            output.append(o)
        return output

```



代码运行截图 <mark>（至少包含有"Accepted"）</mark>
![alt text](image.png)




### M22275: 二叉搜索树的遍历

http://cs101.openjudge.cn/practice/22275/


思路：
二叉搜索树，我们即可知道中序遍历即为123...n,我们由前序和中序可以推断出树的结构，再根据树的结构推出后序排序


代码：

```python
class Treenode():
    def __init__(self,val=0,left=None,right=None):
        self.val=val
        self.left=left
        self.right=right
def tree(l1,l2):
    node=Treenode(l1[0])
    if len(l1)==1:
        return node
    t=l2.index(l1[0])
    if t!=0:
        node.left=tree(l1[1:t+1],l2[0:t])
    if t!=len(l2)-1:
        node.right=tree(l1[t+1:],l2[t+1:])
    return node
def output(node):
    if node.left:
        output(node.left)
    if node.right:
        output(node.right)
    ans.append(node.val)
n=int(input())
l1=list(map(int,input().split()))
l2=[i for i in range(1,n+1)]
root=tree(l1,l2)
ans=[]
output(root)
print(' '.join(str(x) for x in ans))
```



代码运行截图 <mark>（至少包含有"Accepted"）</mark>
![alt text](image-1.png)




### M25145: 猜二叉树（按层次遍历）

http://cs101.openjudge.cn/practice/25145/

思路：
与上题类似根据中序遍历和后序遍历确定树的结构，再根据树的结构写出前序遍历


代码：

```python
class Treenode():
    def __init__(self,val=0,left=None,right=None):
        self.val=val
        self.left=left
        self.right=right
def tree(l1,l2):
    node=Treenode(l2[-1])
    if len(l1)==1:
        return node
    t=l1.index(l2[-1])
    if t!=0:
        node.left=tree(l1[0:t],l2[0:t])
    if t!=len(l2)-1:
        node.right=tree(l1[t+1:],l2[t:-1])
    return node
n=int(input())
for i in range(n):
    l1=input()
    l2=input()
    root=tree(l1,l2)
    ans=[]
    nodes=[root]
    while nodes:
        ns=[]
        for node in nodes:
            ans.append(node.val)
            if node.left:
                ns.append(node.left)
            if node.right:
                ns.append(node.right)
        nodes=ns
    print(''.join(str(x) for x in ans))

```



代码运行截图 <mark>（至少包含有"Accepted"）</mark>
![alt text](image-2.png)




### T20576: printExp（逆波兰表达式建树）

http://cs101.openjudge.cn/practice/20576/

思路：
这题很复杂做不出来，容易有的想法是用栈处理括号，但是要处理逻辑顺序以及判断括号合理性仅仅用栈还不够，得通过建立二叉树将二元和一元运算符的运算对象与运算表达式结合，再通过优先级判断是否需要加括号，判断的方式是比较根与子的运算符优先级。


代码

```python
class TreeNode:
    def __init__(self, val=None, left=None, right=None,symbol=None):
        self.val = val
        self.left = left
        self.right = right

def postorder(sentence):
    operators=[]
    ans=[]
    s=sentence.split()
    weight={'not':3,'and':2,'or':1,'(':0}
    for word in s:
        if word in ('True','False'):
            ans.append(word)
        elif word=='(':
            operators.append(word)
        elif word==')':
            while operators and operators[-1]!='(':
                ans.append(operators.pop())
            operators.pop()
        else:
            while operators and weight[operators[-1]]>=weight[word]:
                ans.append(operators.pop())
            operators.append(word)
    while operators:
        ans.append(operators.pop())
    return ans

def buildTree(inlist):
    stack=[]
    for word in inlist:
        if word in ('True','False'):
            stack.append(TreeNode(word))
        elif word=='not':
            a=stack.pop()
            stack.append(TreeNode('not',a))
        else:
            a=stack.pop()
            b=stack.pop()
            stack.append(TreeNode(word,b,a))
    return stack[0]

level={'or':1,'and':2,'not':3,'True':4,'False':4}

def printTree(root):#返回中序输出
    if root.val in ('True','False'):
        return [root.val]
    elif root.val=='not':
        a=root.left
        b=printTree(a)
        if level[a.val]<level[root.val]:
            b=['(']+b+[')']
        return ['not']+b
    else:
        l=root.left
        r=root.right
        lefttree=printTree(l)
        righttree=printTree(r)
        if level[l.val]<level[root.val]:
            lefttree=['(']+lefttree+[')']
        if level[r.val]<level[root.val]:
            righttree=['(']+righttree+[')']
        return lefttree+[root.val]+righttree
ini=input().strip()
ansl=postorder(ini)
ans2=printTree(buildTree(ansl))
print(' '.join(ans2))
```



代码运行截图<mark>（至少包含有"Accepted"）</mark>
![alt text](image-4.png)




### T04080:Huffman编码树

greedy, http://cs101.openjudge.cn/practice/04080/

思路：
我们考虑一步步化简这棵树，对于两个k层的外生节点a和b，我们将其划归到他们的根节点，并且在综合上加a和b就可以将这两个节点删去，只保留其根节点作为新的外生节点，从而化简了树。递归的一步步化简可得结果。


代码

```python
import heapq

def main():
    n = int(input().strip())
    weights = list(map(int, input().split()))
    
    heapq.heapify(weights)
    total_cost = 0
    
    while len(weights) > 1:
        a = heapq.heappop(weights)
        b = heapq.heappop(weights)
        cost = a + b
        total_cost += cost
        heapq.heappush(weights, cost)
    
    print(total_cost)

if __name__ == "__main__":
    main()
```



代码运行截图<mark>（至少包含有"Accepted"）</mark>
![alt text](image-3.png)




### M04078: 实现堆结构

http://cs101.openjudge.cn/practice/04078/

要求手搓堆实现。

思路：

手搓数据结构对深刻理解数据结构很有益处，更深层的理解了使用方式，并且可以更容易理解一些变式用法，例如最大堆 

代码：

```python
class MinHeap:
    def __init__(self, array=None):
        self.heap = []
        if array is not None:
            self.heap = array[:]  
            self._heapify()
    def _parent_index(self, index):
        """返回父节点索引"""
        return (index - 1) // 2
    
    def _left_child_index(self, index):
        """返回左孩子索引"""
        return 2 * index + 1
    
    def _right_child_index(self, index):
        """返回右孩子索引"""
        return 2 * index + 2
    
    def _has_parent(self, index):
        """检查是否有父节点"""
        return self._parent_index(index) >= 0
    
    def _has_left_child(self, index):
        """检查是否有左孩子"""
        return self._left_child_index(index) < len(self.heap)
    
    def _has_right_child(self, index):
        """检查是否有右孩子"""
        return self._right_child_index(index) < len(self.heap)
    
    def _swap(self, i, j):
        """交换两个元素"""
        self.heap[i], self.heap[j] = self.heap[j], self.heap[i]
    
    def _heapify_up(self, index=None):
        """从下往上调整堆"""
        if index is None:
            index = len(self.heap) - 1
        
        # 如果当前节点比父节点小，就向上交换
        while (self._has_parent(index) and 
               self.heap[index] < self.heap[self._parent_index(index)]):
            parent_index = self._parent_index(index)
            self._swap(index, parent_index)
            index = parent_index
    
    def _heapify_down(self, index=0):
        """从上往下调整堆"""
        # 当有左孩子时继续调整
        while self._has_left_child(index):
            # 找到最小的孩子
            smaller_child_index = self._left_child_index(index)
            if (self._has_right_child(index) and 
                self.heap[self._right_child_index(index)] < self.heap[smaller_child_index]):
                smaller_child_index = self._right_child_index(index)
            
            # 如果当前节点比最小孩子小，堆已经正确
            if self.heap[index] < self.heap[smaller_child_index]:
                break
            else:
                # 否则交换并继续向下调整
                self._swap(index, smaller_child_index)
                index = smaller_child_index
    
    def _heapify(self):
        """将整个数组构建为堆"""
        # 从最后一个非叶子节点开始向上调整
        start_index = len(self.heap) // 2 - 1
        for i in range(start_index, -1, -1):
            self._heapify_down(i)
    
    def push(self, value):
        """向堆中添加元素"""
        self.heap.append(value)
        self._heapify_up()
    
    def pop(self):
        """弹出堆顶最小元素"""
        if len(self.heap) == 0:
            raise IndexError("堆为空")
        min_value = self.heap[0]
        last_value = self.heap.pop()
        
        if len(self.heap) > 0:
            self.heap[0] = last_value
            self._heapify_down()
        
        return min_value
    def is_valid(self):
        """验证堆是否满足最小堆性质"""
        for i in range(len(self.heap)):
            left = self._left_child_index(i)
            right = self._right_child_index(i)
            
            if self._has_left_child(i) and self.heap[i] > self.heap[left]:
                return False
            if self._has_right_child(i) and self.heap[i] > self.heap[right]:
                return False
        return True
n=int(input())
heap=MinHeap()
for i in range(n):
    m=list(map(int,input().split()))
    if m[0]==1:
        heap.push(m[1])
    else:
        print(heap.pop())
```



代码运行截图 <mark>（至少包含有"Accepted"）</mark>
![alt text](image-5.png)


## 2. 学习总结和个人收获

<mark>如果发现作业题目相对简单，有否寻找额外的练习题目，如“数算2025fall每日选做”、LeetCode、Codeforces、洛谷等网站上的题目。</mark>
这次的波兰表达式那题颇有难度，从各方面都对数据结构的处理和理解有着要求。学了这么多数据结构下来，感觉到每次做题都是知道本章在用什么数据结构，或许考试突然做一道题不知道改用数据结构，或者是说该用什么数据结构。重要的应该是清晰理解各种数据结构的用法。

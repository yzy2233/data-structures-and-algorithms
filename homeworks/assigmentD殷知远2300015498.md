## 1. 题目

### E02734:十进制到八进制 

http://cs101.openjudge.cn/practice/02734

思路：
每次对8取余从后获得八进制的每一位


代码

```python
n=int(input())
ans=0
t=0
while n>0:
    m=n%8
    if m==0:
        n=(n-8)//8
        m=10
    else:
        n=(n-m)//8
    ans=m*(10**t)+ans
    t+=1
print(ans)
```



代码运行截图 <mark>（至少包含有"Accepted"）</mark>
![alt text](image.png)




### M21509:序列的中位数

heap, http://cs101.openjudge.cn/practice/21509

思路：
维护一个前一半的最大堆和后一半的最小堆，每次可以方便的取出中位数前后的两个数，然后每次加入两个数对两个堆进行维护，以简化获得中位数的复杂度


代码

```python
import heapq

n = int(input())
l = list(map(int, input().split()))

left_heap = []   # 最大堆（用负数实现）
right_heap = []  # 最小堆

for i in range(n):
    num = l[i]
    
    # 插入新元素
    if not left_heap or num <= -left_heap[0]:
        heapq.heappush(left_heap, -num)
    else:
        heapq.heappush(right_heap, num)
    
    # 平衡堆
    if len(left_heap) > len(right_heap) + 1:
        heapq.heappush(right_heap, -heapq.heappop(left_heap))
    elif len(right_heap) > len(left_heap):
        heapq.heappush(left_heap, -heapq.heappop(right_heap))
    
    # 只有当处理了奇数个数时才输出中位数
    if (i + 1) % 2 == 1:  # i=0,2,4,6... 对应第1,3,5,7...个数
        median = -left_heap[0]
        print(median)
```



代码运行截图 <mark>（至少包含有"Accepted"）</mark>

![alt text](image-1.png)



### M27306: 植物观察

disjoint set, bfs, http://cs101.openjudge.cn/practice/27306/

思路：
将同一类的植物合成一个并查集，用bfs进行连通分支的搜索。如果两个被分在同一个并查集与条件的断言冲突，则报错


代码

```python
from collections import defaultdict, deque

def solve():
    n, m = map(int, input().split())
    
    # 构建邻接表
    graph = defaultdict(list)
    
    # 读取所有关系
    for _ in range(m):
        a, b, relation = map(int, input().split())
        graph[a].append((b, relation))
        graph[b].append((a, relation))
    
    # 颜色数组：-1表示未访问，0/1表示两种颜色
    color = [-1] * n
    visited = [False] * n
    
    # 遍历所有节点（处理可能的不连通图）
    for i in range(n):
        if color[i] == -1:  # 发现新的连通分量
            # 初始化BFS
            queue = deque([i])
            color[i] = 0  # 初始化为颜色0
            visited[i] = True
            
            while queue:
                node = queue.popleft()
                
                # 遍历所有邻居
                for neighbor, relation in graph[node]:
                    # 计算邻居应有的颜色
                    # 如果relation=0（相同），则颜色相同
                    # 如果relation=1（不同），则颜色不同
                    expected_color = color[node] ^ relation
                    
                    if color[neighbor] == -1:  # 邻居未访问
                        color[neighbor] = expected_color
                        queue.append(neighbor)
                        visited[neighbor] = True
                    elif color[neighbor] != expected_color:  # 颜色矛盾
                        return "NO"
    
    return "YES"

if __name__ == "__main__":
    print(solve())
```



代码运行截图 <mark>（至少包含有"Accepted"）</mark>

![alt text](image-2.png)



### M29740:神经网络

Topological order, http://cs101.openjudge.cn/practice/29740/


思路：
拓扑排序求出层序结构，再bfs前向传播按要求更新状态 。
注：这题暂时还未通过，但我自己使用的测试样例基本都没问题，希望老师看到能指正代码，或者提供更多样例。

代码

```python
from collections import deque
def main():
    n,p=map(int,input().split())
    c=[]
    u=[]
    start=[]
    end=[i for i in range(n)]
    for _ in range(n):
        a,b=map(int,input().split())
        c.append(a)
        u.append(b)
    l=[[0 for __ in range(n)] for _ in range(n)]
    deg=[0 for i in range(n)]
    for _ in range(p):
        x,y,wxy=map(int,input().split())
        l[x-1][y-1]+=wxy
        deg[y-1]+=1
        if x-1 in end:
            end.remove(x-1)
    for i in range(n):
        if deg[i]==0:
            start.append(i)
    #print(start,end)
    start0=start[:]
    sorted_nodes=start
    q=deque(start)
    while q:
        node=q.popleft()
        for i in range(n):
            if i==node:
                continue
            if l[node][i]!=0:
                deg[i]-=1
                if deg[i]==0:
                    sorted_nodes.append(i)
                    q.append(i)
    if len(sorted_nodes)!=n:
        print('NULL')
        return
    sorted_q=deque(sorted_nodes)
    #print(start0,start)
    while sorted_q:
        node=sorted_q.popleft()
        if node not in start0:
            c[node]-=u[node]
        for i in range(n):
            if l[node][i]!=0 and c[node]>0:
                c[i]+=l[node][i]*c[node]
    sig=0
    for j in end:
        if c[j]>0:
            print(j+1,c[j])
            sig=1
    if sig==0:
        print("NULL")
if __name__=="__main__":
    main()
```



代码运行截图 <mark>（至少包含有"Accepted"）</mark>





### T27351:01最小生成树 

mst, http://cs101.openjudge.cn/practice/27351/

思路：

最小生成树的边权和其实就是连通分支数减一，所以同样使用并查集求连通分支数即可

代码

```python
from collections import deque

def main():
    n, m = map(int, input().split())
    
    # 邻接表存储1权边
    adj = [set() for _ in range(n)]
    
    for _ in range(m):
        x, y = map(int, input().split())
        x -= 1
        y -= 1
        adj[x].add(y)
        adj[y].add(x)
    
    visited = [0] * n
    unvisited = set(range(n))
    components = 0
    
    while unvisited:
        components += 1
        start = unvisited.pop()
        visited[start] = 1
        q = deque([start])
        
        while q:
            u = q.popleft()
            # 找出所有与u有0权边的未访问节点
            to_visit = []
            for v in unvisited:
                if v not in adj[u]:  # 0权边
                    to_visit.append(v)
            
            for v in to_visit:
                unvisited.remove(v)
                visited[v] = 1
                q.append(v)
    
    print(components - 1)

if __name__ == "__main__":
    main()
```



代码运行截图 <mark>（至少包含有"Accepted"）</mark>

![alt text](image-4.png)



### T30193:哈密顿激活层

DFS+剪枝, http://cs101.openjudge.cn/practice/30193/

思路：
这题难度较大，且难度在于剪枝。
时间锁约束
路径第 t 步必须到达某个特定格子。这意味着：
在 DFS 过程中，如果当前步数 step 等于某个关键格子的时间 t，则必须在这个格子。
如果 step 小于某个时间 t，你不能提前走到那个格子（因为一旦走到就占了那个时间步，后续不能改变顺序）。
换句话说：对每个格子 (r,c)，如果它是关键格子，时间 t 已知，那么：
当 step == t 时，必须在这个格子，否则非法。
当 step != t 时，不能在这个格子。
所以搜索时当前位置必须满足时间锁匹配。
连通性剪枝
如果剩下的未访问的正常格子不连通，则不可能走完，提前剪枝。
时间可行性剪枝
设 step 是当前已走步数，剩余格子数 remaining = P - step。
从当前位置 (r,c) 到某个关键格子 (r_k, c_k) 的时间 t_k，必须满足剩余步数足够到达（曼哈顿距离 ≤ 剩余时间），并且时间差必须合理。
更严格：如果我们把关键格子按时间排序，下一个最近的关键格子 t_next，必须在 step + 曼哈顿距离 ≤ t_next 的情况下才能到达，并且剩余步数要匹配。
死胡同剪枝（Articulation point 剪枝）
在网格哈密顿路径问题中常用：如果当前格子的邻居中，有超过 1 个未访问的正常格子是“死胡同”（即该格子只有一个未访问邻居），则不可能在不重复访问的情况下走完所有格子。

可以看出不仅要求熟悉代码，也要善于思考情景，对相关的数据结构和问题有深入理解（比如哈密顿路径）
代码

```python
import sys
sys.setrecursionlimit(10000)

def main():
    input = sys.stdin.read().strip().split()
    idx = 0
    N = int(input[idx]); idx += 1
    M = int(input[idx]); idx += 1
    K = int(input[idx]); idx += 1
    B = int(input[idx]); idx += 1

    # 网格，0 表示正常，-1 表示障碍物
    grid = [[0] * (M + 2) for _ in range(N + 2)]
    # 边界也设为障碍物便于处理
    for i in range(N + 2):
        grid[i][0] = grid[i][M + 1] = -1
    for j in range(M + 2):
        grid[0][j] = grid[N + 1][j] = -1

    time_lock = {}
    start = None
    for _ in range(K):
        r = int(input[idx]); idx += 1
        c = int(input[idx]); idx += 1
        t = int(input[idx]); idx += 1
        time_lock[(r, c)] = t
        if t == 1:
            start = (r, c)

    for _ in range(B):
        r = int(input[idx]); idx += 1
        c = int(input[idx]); idx += 1
        grid[r][c] = -1

    # 检查起点是否存在
    if start is None:
        print(-1)
        return

    total_cells = N * M - B  # 需要访问的总格子数

    # 预处理正常格子坐标
    normal_cells = []
    for r in range(1, N + 1):
        for c in range(1, M + 1):
            if grid[r][c] == 0:
                normal_cells.append((r, c))

    # 方向
    dirs = [(1, 0), (-1, 0), (0, 1), (0, -1)]

    visited = [[False] * (M + 2) for _ in range(N + 2)]
    path = [None] * (total_cells + 1)

    # 邻接表用于连通性检查（未访问的正常格子）
    # 提前计算每个格子的邻居数（正常格子）
    def unvisited_neighbors(r, c, vis):
        count = 0
        for dr, dc in dirs:
            nr, nc = r + dr, c + dc
            if grid[nr][nc] == 0 and not vis[nr][nc]:
                count += 1
        return count

    # 连通性检查：从某个未访问的正常格子开始 BFS，看能访问多少未访问的正常格子
    def is_connected(vis):
        # 找到第一个未访问的正常格子
        start_uv = None
        for r in range(1, N + 1):
            for c in range(1, M + 1):
                if grid[r][c] == 0 and not vis[r][c]:
                    start_uv = (r, c)
                    break
            if start_uv:
                break
        if start_uv is None:
            return True  # 没有未访问的格子了，无所谓连通
        from collections import deque
        q = deque([start_uv])
        temp_vis = [[False] * (M + 2) for _ in range(N + 2)]
        temp_vis[start_uv[0]][start_uv[1]] = True
        count = 0
        while q:
            r, c = q.popleft()
            count += 1
            for dr, dc in dirs:
                nr, nc = r + dr, c + dc
                if grid[nr][nc] == 0 and not vis[nr][nc] and not temp_vis[nr][nc]:
                    temp_vis[nr][nc] = True
                    q.append((nr, nc))
        # 计算未访问的正常格子总数
        total_uv = 0
        for r in range(1, N + 1):
            for c in range(1, M + 1):
                if grid[r][c] == 0 and not vis[r][c]:
                    total_uv += 1
        return count == total_uv

    # 关键时间检查
    def check_time_lock(step, r, c):
        if (r, c) in time_lock:
            return time_lock[(r, c)] == step
        # 如果这个格子不是关键格子，但它被其他关键格子的时间锁约束
        # 即：其他关键格子的时间不能等于 step
        for (kr, kc), t in time_lock.items():
            if t == step:
                # 这个时间步必须走 (kr, kc)，不能走别的格子
                if (r, c) != (kr, kc):
                    return False
        return True

    # 死胡同剪枝
    def dead_end_check(r, c, vis, step):
        # 如果当前格子的未访问邻居数 > 1，其中 >= 2 个邻居的未访问邻居数 == 1，则不可能走完
        # 这里简化：如果有两个未访问邻居都是死胡同（只有一个未访问邻居即当前格子），则不可能走完
        uv_neighbors = []
        for dr, dc in dirs:
            nr, nc = r + dr, c + dc
            if grid[nr][nc] == 0 and not vis[nr][nc]:
                uv_neighbors.append((nr, nc))
        dead_count = 0
        for nr, nc in uv_neighbors:
            if unvisited_neighbors(nr, nc, vis) == 1:  # 唯一未访问邻居是当前格子
                dead_count += 1
        if dead_count > 1:
            return False
        return True

    found = False

    def dfs(r, c, step):
        nonlocal found
        if found:
            return

        # 时间锁检查
        if not check_time_lock(step, r, c):
            return

        # 死胡同剪枝
        if not dead_end_check(r, c, visited, step):
            return

        # 放置当前位置
        path[step] = (r, c)
        visited[r][c] = True

        # 完成条件
        if step == total_cells:
            found = True
            return

        # 连通性剪枝
        if not is_connected(visited):
            visited[r][c] = False
            return

        # 对邻居进行 DFS，按启发式排序：先走可能约束紧的邻居
        neighbors = []
        for dr, dc in dirs:
            nr, nc = r + dr, c + dc
            if grid[nr][nc] == 0 and not visited[nr][nc]:
                # 检查这个邻居是否符合时间锁（下一步 step+1）
                if not check_time_lock(step + 1, nr, nc):
                    continue
                neighbors.append((nr, nc))

        # 可以按启发式排序：优先走向关键格子的邻居
        def sort_key(pos):
            nr, nc = pos
            # 如果是关键格子且时间紧，优先
            if (nr, nc) in time_lock:
                return 0
            return 1

        neighbors.sort(key=sort_key)

        for nr, nc in neighbors:
            dfs(nr, nc, step + 1)
            if found:
                return

        visited[r][c] = False

    # 开始 DFS
    dfs(start[0], start[1], 1)

    if found:
        for i in range(1, total_cells + 1):
            print(path[i][0], path[i][1])
    else:
        print(-1)

if __name__ == "__main__":
    main()
```



代码运行截图 <mark>（至少包含有"Accepted"）</mark>
![alt text](image-3.png)




## 2. 学习总结和收获

如果作业题目简单，有否额外练习题目，比如：OJ“计概2025fall每日选做”、CF、LeetCode、洛谷等网站题目。
月考依旧很有难度，完全没有自信在固定时间内解答完。除了第一题比较送分外，每题都可以看出老师要考察的重点，不仅考察明确而且贴近实际应用，非常有收获，对数据结构的理解也更上一层，还希望自己多熟悉相关常见写法，以便在考场上加快解题速度，考试真的很有难度也考验基本功。